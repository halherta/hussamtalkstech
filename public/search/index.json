[{"content":"The topic of bit manipulation in C doesn\u0026rsquo;t seem to get as much attention in many C programming books and study guides. Perhaps because it\u0026rsquo;s a not used regularly by application developers and system programmers.\nKnowledge of bit manipulation is however downright critical in the fields of embedded systems, kernel space programming and device drivers programming, where the programmer directly accesses registers i.e. talking to hardware.\nProgrammer\u0026rsquo;s access registers directly via Read-Modify-Write (RMW) operations. RMW operations in turn rely heavily on bitwise operators and other parts of the C programming language that facilitate bit manipulation. In order to understand and correctly use RMW operations, a solid foundation in the basics of bit manipulation must me developed. This article will attempt to provide the reader with said foundation.\nBitwise operators Let us first start by introducing the bitwise operators:\nBitwise operator Description What it does \u0026amp; Bitwise AND operator \u0026lsquo;AND\u0026rsquo;s two values at the binary level | Bitwise OR operator \u0026lsquo;OR\u0026rsquo;s two values at the binary level ^ Bitwise XOR operator \u0026lsquo;XOR\u0026rsquo;s two values at the binary level ~ Bitwise One\u0026rsquo;s complement operator Flips every bit in the register \u0026gt;\u0026gt; Bitwise right shift operator Shifts a value to the right at the bit level by a specified number of bits \u0026lt;\u0026lt; Bitwise left shift operator Shifts a value to the left at the bit level by a specified number of bits Consider the code snippet below. It declares three unsigned 8 bit integer variables; a,b \u0026amp; y. And initializes a to 200, b to 56 and y to 0.\nuint8_t a = 200; uint8_t b = 56; uint8_t y = 0; The One\u0026rsquo;s complement (NOT) unary operator simply flips all of the bits at a binary level as shown in Figure 1.\ny = ~a; If a bitwise AND is performed between a and b, the result is 8. Note how the bitwise AND operation performs a Boolean logical ANDing at the bit level.\ny = a \u0026amp; b; A bitwise OR performed between a and b, results in 248.\ny = a | b; A bitwise XOR performed between a and b, results in 240.\ny = a ^ b; A bitwise right shift (by three bits) performed on a, results in 25.\ny = a \u0026gt;\u0026gt; 3; And finally, a bitwise left shift (by 3 bits) performed on a, results in 64.\ny = a \u0026lt;\u0026lt; 3; The only reason this result is only 64, is because the three most significant bits are outside the bounds of the unsigned 8-bit integer variable and are therefore truncated i.e. they don\u0026rsquo;t count. If a and y where both say 16 bit unsigned integers, the result of this operation becomes 1600.\nNote that shifting a value to the left by x bits, is equivalent to multiplying that value by \\(2^x\\). This is exactly what happened here i.e. \\(200 \u003c\u003c 3\\) is equivalent to 200 * \\(2^3\\) . More on this in the next paragraph.\nAt this point it is important to note that bit shifts can facilitate multiplication and division operations by\u0026rsquo;power of two\u0026rsquo; literals. For example, if our goal is to multiply a variable x by 8 ( \\(2^3\\) ), it can be achieved through good old fashioned multiplication; or by bit shifting the variable x by 3 times to the left.\ny = x * 8; is equivalent to y = x \u0026lt;\u0026lt; 3;\nSimilarly, dividing (integer division) a variable x by 8 \\(2^3\\), can be achieved by bit shifting the variable x by 3 times to the right.\ny = x / 8; is equivalent to y = x \u0026gt;\u0026gt; 3;\nYou can verify all the operations mentioned so far by compiling and running this simple C program with GCC or your favourite C compiler:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int main (void) { uint8_t a,b,c,y; uint16_t a16, y16; a = 200; b = 56; c = 16; y = 0; a16 = 200; y16 = 0; y = ~200; printf(\u0026#34; The one\u0026#39;s complement (NOT) of 200 is %i \\n\u0026#34;,(unsigned int)y); y = a \u0026amp; b; printf(\u0026#34; Bitwise ANDING of 200 and 56 gives %i \\n\u0026#34;,(unsigned int)y); y = a | b; printf(\u0026#34; Bitwise ORING of 200 and 56 gives %i \\n\u0026#34;,(unsigned int)y); y = a ^ b; printf(\u0026#34; Bitwise XORING of 200 and 56 gives %i \\n\u0026#34;,(unsigned int)y); y = a \u0026lt;\u0026lt; 3; printf(\u0026#34; Bitwise left shift by 3 of the value 200 (8-bit) gives %i \\n\u0026#34;,(unsigned int)y); y16 = a16 \u0026lt;\u0026lt; 3; printf(\u0026#34; Bitwise left shift by 3 of the value 200 (16-bit) gives %i \\n\u0026#34;,(unsigned int)y16); y = a \u0026gt;\u0026gt; 3; printf(\u0026#34; Bitwise right shift by 3 of the value 200 gives %i \\n\u0026#34;,(unsigned int)y); printf(\u0026#34; Multiplying the value 16 by 8 (2^3) gives %i. Bit shifting the value 16 by 3 bits to the left also gives %i \\n\u0026#34;,(unsigned int)c*8, (unsigned int) c\u0026lt;\u0026lt;3); printf(\u0026#34; Dividing the value 16 by 8 (2^3) gives %i. Bit shifting the value 16 by 3 bits to the right also gives %i \\n\u0026#34;,(unsigned int)c/8, (unsigned int) c\u0026gt;\u0026gt;3); return 0; } when compiling and running the above program, it outputs:\nThe one\u0026#39;s complement (NOT) of 200 is 55 Bitwise ANDING of 200 and 56 gives 8 Bitwise ORING of 200 and 56 gives 248 Bitwise XORING of 200 and 56 gives 240 Bitwise left shift by 3 of the value 200 (8-bit) gives 64 Bitwise left shift by 3 of the value 200 (16-bit) gives 1600 Bitwise right shift by 3 of the value 200 gives 25 Multiplying the value 16 by 8 (2^3) gives 128. Bit shifting the value 16 by 3 bits to the left also gives 128 Dividing the value 16 by 8 (2^3) gives 2. Bit shifting the value 16 by 3 bits to the right also gives 2 Compound assignment operators The compound assignment operators consist of a binary operator (operator that operates on two variables) and the simple assignment operator. They perform the operation of the binary operator on both operands and store the result of that operation into the left operand i.e. x += y adds the values of variables x and y and stores the result back into x. This operation is a shorthand version of x = x + y\nAll arithmetic compound assignment operators and their expanded equivalent operations are listed below:\nCompound assignment Equivalent expanded assignment x \u0026lt;op\u0026gt;= y x = x \u0026lt;op\u0026gt; y x += y x = x + y x -= y x = x \u0026ndash; y x *= y x = x * y x /= y x = x / y Compound assignment operator notation also works for all 2-variable (binary) bitwise operators:\nCompound assignment Expanded equivalent x \u0026amp;= y x = x \u0026amp; y x |= y x = x | y x ^= y x = x ^ y x \u0026lt;\u0026lt;= y x = x \u0026lt;\u0026lt; y x \u0026gt;\u0026gt;= y x = x \u0026gt;\u0026gt; y There\u0026rsquo;s no compound assignment operator for the bitwise one\u0026rsquo;s complement operator ~ since it a unary operator.\nNon-Decimal Numerical Representation in C In C an integer number can be represented in decimal, binary, hexadecimal and octal formats through the use of prefixes:\nTo represent a number in decimal no prefix is needed, i.e. x = 255 To represent a binary, precede it with a 0b, i.e. x = 0b11111111 To represent a number in hexadecimal, precede it with a 0x, i.e. x = 0xff To represent a number in octal, precede it with 0, i.e. x = 0377 While the numerical representation utilized matters little to the compiler (all numbers end up being processed in binary), in some instances using different numerical representations when writing a program can improve the readability of the program.\nAnother way to represent a number is to left shift a 1 by an arbitrary number of bits. consider the number 8. In binary, number 8 is represented as 0b00001000. That\u0026rsquo;s basically a \u0026lsquo;1\u0026rsquo; in the third position (start counting from right to left). Therefore number 8 can also be represented with a left shift operation as 1 \u0026lt;\u0026lt; 3.\nIn a similar manner we have:\nDecimal Binary equivalent Bit mask equivalent 1 0b00000001 1 \u0026lt;\u0026lt; 0 2 0b00000010 1 \u0026lt;\u0026lt; 1 4 0b00000100 1 \u0026lt;\u0026lt; 2 8 0b00001000 1 \u0026lt;\u0026lt; 3 16 0b00010000 1 \u0026lt;\u0026lt; 4 32 0b00100000 1 \u0026lt;\u0026lt; 5 64 0b01000000 1 \u0026lt;\u0026lt; 6 128 0b10000000 1 \u0026lt;\u0026lt; 7 Using this mask representation works nicely for numbers that are powers of two. Since these numbers consist of a single \u0026lsquo;1\u0026rsquo; value (set bit) in a particular bit position. What if we have a number that was not a power of two, say something like 14 or 25?\nNumber 14 is equivalent to 8+4+2, or in binary 0b00001110. This can be written as: (1 \u0026lt;\u0026lt; 3) | (1 \u0026lt;\u0026lt; 2) | (1 \u0026lt;\u0026lt; 1) Number 25 is equivalent to 16+8+1 or in binary 0b00011001. This can be written as (1 \u0026lt;\u0026lt; 4) | (1 \u0026lt;\u0026lt; 3) | (1 \u0026lt;\u0026lt; 0) Using this approach, any positive integer can be represented using this mask representation by either a single left shift of 1 , or by bitwise ORing multiple left shifts of \u0026lsquo;1\u0026rsquo; !\nThe reader is now ready to tackle RMW operations! They will be covered in the next article in this series.\n","date":"2024-06-02T00:00:00Z","permalink":"http://localhost:1313/p/bit-manipulation-in-c-part-i-bit-manipulation-basics/","title":"Bit Manipulation in C Part I - Bit Manipulation Basics"},{"content":"This article covers Read Modify Write (RMW) operations. These operations allow the programmer to manipulate one or more bits of interest within a variable (or register), without affecting the state of the rest of the bits in the that variable (or register). In order to understand RMW operations, the reader must have a solid foundation in bit manipulation. Bit manipulation basics were covered in the Bit Manipulation in C Part 1 - Bit Manipulation basics article.\nThere are four main RMW operations:\nSetting one or more bits in a register. Clearing one or more bits in a register. Toggling one or more bits in a register. Reading the value of a particular bit within a register. For the rest of this blog entry variables and / or registers will be referred to as registers for brevity. Both refer to locations in memory where data is stored. The term register is typically used when referencing memory locations capable of directly affecting hardware operation of either the CPU or a hardware peripheral.\nThe reason why these type of operations are often referred to as Read-Modify-Write is because they involve:\nReading the state of the register, Modifying the state of that register by performing a bitwise logical operation on the value read from the register, with a bit mask of some kind intending to modify one or more (particular) bits within the register , and finally, Write-ing back the result into the same register. Only the bits of interest are modified by an RMW operation. the state of the bits that are not of interest within the register never changes.\nSetting one or more bits in a register The first RMW operation that will be examined is the set operation. The goal here is to set one or more bit(s) of interest in a register, without disturbing the state of the other bits that are not of interest. To achieve this, OR the current content of the register with a mask value with only one(s) in the bit location(s) to be set and zeroes elsewhere.\nTo further elaborate, if the value of a register (or variable) a is 200. To set bit x in that register, OR a with a mask value of 2^x^.\nConsider the following example (See Figure 1.). If the goal is to set bit 5 in register a, the mask is 2^5^ = 32. The set operation then becomes:\na= a | 32; which is equivalent the following compound assignment statement:\na |= 32; Alternatively 32 can be written as (1 \u0026lt;\u0026lt; 5) in C. This mask notation is easier to read and immediately indicates to the reader/programmer which bit is being set. The final operation becomes:\na |= (1 \u0026lt;\u0026lt; 5); In summary to set a bit x in register reg, use the following expression:\nreg |= (1 \u0026lt;\u0026lt; x); What if the programmer needs to set more than one bit in register reg, say bit positions x, y and z?\nreg |= ((1 \u0026lt;\u0026lt; x) | (1 \u0026lt;\u0026lt; y) | (1 \u0026lt;\u0026lt; z)); Clearing one or more bits in a register The goal here is to clear one or more particular bit(s) in a register, without disturbing the state of the other bits that are not of interest. To achieve this, AND the current content of the register with a mask value with zero(es) in the bit location(s) that we want to clear and ones elsewhere.\nIf the value of the register a is 200. To clear bit x in that register, the content of register a is ANDed with a mask that is the inverted (one\u0026rsquo;s complement) value of 2^x^.\nFor example, if the goal is to clear bit 6. the mask becomes the one\u0026rsquo;s complement of 2^6^ = 64 which results in 191. Therefore to clear bit 6 in register a:\na= a \u0026amp; 191; which is equivalent to the following compound assignment statement\na \u0026amp;= 191; Alternatively 191 can be written as ~(1 \u0026lt;\u0026lt; 6) in C. This mask notation is much more readable as it indicates to the reader/programmer which bit is being cleared without having to resort to doing decimal to binary conversion.\na \u0026amp;= ~(1 \u0026lt;\u0026lt; 6); In summary, to clear a bit x in register reg use the following expression:\nreg \u0026amp;= ~(1 \u0026lt;\u0026lt; x); What if the programmer needs to clear more than one bit in register reg, say bits x, y and z ?\nreg \u0026amp;= ~((1 \u0026lt;\u0026lt; x) | (1 \u0026lt;\u0026lt; y) | (1 \u0026lt;\u0026lt; z)); Toggling one or more bits in a register The goal here is to toggle one or more particular bit(s) in a register, without disturbing the state of the other bits that are not of interest. To achieve this, XOR the current content of the register with a mask value with one(s) in the bit locations to be toggled and zeroes elsewhere.\nFor example if the value of a register a is 200, to toggle bit \u0026lsquo;x\u0026rsquo; in that register, one will need to XOR a with a mask value of 2^x^.\nTo further elaborate, If the goal is to toggle bit 5 in register a, the mask is 2^5^ = 32. The set operation then becomes:\na= a ^ 32 ; which is equivalent to\na ^= 32; in shorthand notation. Alternatively 32 can be written as (1 \u0026lt;\u0026lt; 5) in C.\na ^= (1 \u0026lt;\u0026lt; 5); In summary, to toggle a bit x in register reg use the following expression:\nreg ^= (1 \u0026lt;\u0026lt; x); What if the programmer needs to toggle more than one bit in register reg, say bits x,y and z ?\nreg ^= ((1 \u0026lt;\u0026lt; x) | (1 \u0026lt;\u0026lt; y) | (1 \u0026lt;\u0026lt; z)); Read the value of bit in a registers To read the value of a bit x in a register a, simply AND register a with a mask value of 2^x^ (i.e. all bit positions are 0\u0026rsquo;s except position x).\nIf the result is 0 then bit x in register a was 0(cleared). If the result is non-zero, then bit x in register a was 1(set).\nFor example to read the state of bit 5 in register a:\nuint8_t a , y; y = a \u0026amp; 32; if(y == 0 ) printf(\u0026#34;Bit 5 in register a is zero\u0026#34;); else printf(\u0026#34;Bit 5 in register a is one\u0026#34;); In C, a non-zero value evaluates to true so the statement\nif(y)Copy will evaluate to true if \u0026lsquo;y\u0026rsquo; is non-zero. Using this knowledge and compund assignment notation, the previous code snippet becomes:\nif(a \u0026amp; (1 \u0026lt;\u0026lt; 5)) printf(\u0026#34;Bit 5 in register a is one\u0026#34;); else printf(\u0026#34;Bit 5 in register a is zero\u0026#34;); In some cases the programmer will want to return the exact state of the bit in a register and not a non-zero value when the state of the bit is one, and zero when the state of the bit is zero. This can be accomplished with the ternary operator. If bit x in register a is 1, res will be 1. else res will be zero.\nres = (a \u0026amp; ( 1\u0026lt;\u0026lt; x )) ? 1 : 0 ; Another method of reading the state of a bit x in register a is to use this statement:\nres = (a \u0026gt;\u0026gt; x) \u0026amp; 1; This shifts the content of register a to the right by x bits, putting the \u0026lsquo;xth\u0026rsquo; bit to be tested in the zeroth position. It is then ANDed with one. If this bit is zero, the result of the operation is zero, else it is one.\nIn summary to read the state of bit x in register a with an if statement:\nif(a \u0026amp; (1 \u0026lt;\u0026lt; x)) printf(\u0026#34;Bit x in register a is one\u0026#34;); else printf(\u0026#34;Bit x in register a is zero\u0026#34;); If the state of the bit is to be returned without an if statement, use either\nres = (a \u0026amp; ( 1\u0026lt;\u0026lt; x ) ) ? 1 : 0 ; or\nres = (a \u0026gt;\u0026gt; x) \u0026amp; 1; Building a bit manipulation library Now with the knowledge of how RMW operations function, a quick library that performs these operations can be built!\nThe macro version should look like this:\n#define m_setBit(reg,x) reg |= (1 \u0026lt;\u0026lt; x) #define m_clearBit(reg,x) reg \u0026amp;= ~(1 \u0026lt;\u0026lt; x) #define m_toggleBit(reg,x) reg ^= (1 \u0026lt;\u0026lt; x) #define m_readBit(reg,x) (reg \u0026gt;\u0026gt; x) \u0026amp; 1 #define m_readBit2(reg,x) (reg \u0026amp; ( 1\u0026lt;\u0026lt; x ) ) ? 1 : 0 If you are not a big fan of macros, the inline function version of the library would look something like this:\nvoid setBit(int* reg, int x){ *reg |= (1 \u0026lt;\u0026lt; x);} void clearBit(int* reg, int x){ *reg \u0026amp;= ~(1 \u0026lt;\u0026lt; x);} void toggleBit(int* reg, int x){ *reg ^= (1 \u0026lt;\u0026lt; x);} int readBit( int* reg, int x){ return (*reg \u0026gt;\u0026gt; x) \u0026amp; 1;} int readBit2( int* reg, int x){ return (*reg \u0026amp; ( 1\u0026lt;\u0026lt; x ) ) ? 1 : 0 ;} Note that these macros/functions only modify one bit at a time.\nOne last thing. The RMW operations introduced in this article are not strictly atomic i.e. they will very likely not happen in a single instruction cycle and may even take several instruction cycles to execute. They merely give us bit granularity i.e. ensure that only the bits of interest within a register are changed while keeping the state of bits that are not of interest undisturbed.\n","date":"2024-06-02T00:00:00Z","permalink":"http://localhost:1313/p/bit-manipulation-in-c-part-ii-read-modify-write-operations/","title":"Bit Manipulation in C Part II - Read Modify Write Operations"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”\n— Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Design Reviewed | Graphic Design History (@DesignReviewed) January 17, 2019 Vimeo Simple Shortcode bilibilibi Shortcode Gist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2019-03-10T00:00:00Z","permalink":"http://localhost:1313/p/rich-content/","title":"Rich Content"}]